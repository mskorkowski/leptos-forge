//! Tailwind integration with for build scripts

use std::collections::HashMap;
use std::collections::HashSet;
use std::env;
use std::fs::File;
use std::fs::create_dir_all;
use std::hash::Hash;
use std::io::Write;
use std::process::Command;

use cargo_metadata::Metadata;
use cargo_metadata::Node;
use cargo_metadata::Package;
use cargo_metadata::PackageId;
use cargo_metadata::Resolve;
use cargo_metadata::camino::Utf8Path;
use cargo_metadata::camino::Utf8PathBuf;
use indoc::formatdoc;
use serde_json::Value;
use soft_canonicalize::soft_canonicalize;

use crate::console::Console;

/// Suffix appended to the `OUT_DIR` environment variable if [`Tailwind::out_dir`]
/// is [None]
const CARGO_OUTDIR_SUFFIX: &str = "leptos_forge/build_script/tailwind";

/// Header of the generated css file
const GENERATED_CSS_FILE_PREFIX: &str = r###"
/* Generated by leptos_forge tailwind integration */

/* Import tailwind */
@import "tailwindcss";

/* Import all dependencies */

"###;

/// Cargo configuration for tailwind integration
#[derive(Debug, serde::Deserialize)]
pub struct TailwindConfiguration {
    /// Relative path to the main tailwind file for the crate
    /// 
    /// If path using `lib` contains `"` or `"` then Tailwind integration will
    /// return an error
    lib: Option<Utf8PathBuf>,
    /// The path to the resulting css file
    /// 
    /// If more then one crate specifies the output path only the root crate
    /// specified one will be built
    /// 
    /// If path using `lib` contains `"` or `"` then Tailwind integration will
    /// return an error
    /// 
    /// 
    output: Option<Utf8PathBuf>,
    /// List of paths from where the changes might come from during the development.
    /// This allows you to fine tune from when the tailwind css file should be
    /// regenerated.
    /// 
    /// If this value is specified you must specify all elements which might 
    /// contribute to the final css file (no defaults will be used).
    /// 
    /// It's only used when 
    /// 
    /// 1. [`Tailwind::auto_local_watch`] is set to `true` or you've 
    ///    manually run the [`Tailwind::watch_dependencies`] method
    /// 2. Only for [packages][PackageDetails] marked as local
    /// 
    /// # Defaults
    /// 
    /// If not set, then it's assumed that this watch contains two entries:
    /// 
    /// 1. Parent folder of the "lib.rs" of your dependency
    /// 2. Parent folder of the file specified in [TailwindConfiguration::lib] 
    /// 
    /// Defaults are safe, but might add to your build time in unnecessary way.
    /// Since rarely whole source code contributes to the view and tailwind in
    /// particular, you probably should 
    /// 
    /// # Usage details
    /// 
    /// Entries from this list will be used to generate the [`cargo::rerun-if-changed=PATH`](https://doc.rust-lang.org/cargo/reference/build-scripts.html#rerun-if-changed)
    /// statements. This will force the build script to rebuild the css
    /// 
    /// ## Disable watching for a crate
    /// 
    /// If you don't need to watch anything in the crate you can set the watch
    /// to point to at your build script.
    /// 
    /// This can be useful if you have a workspace where client code where you
    /// use tailwind classes is in the separate crate and your application just
    /// depends on the client code.
    #[serde(default)] 
    watch: Vec<Utf8PathBuf>,
}

/// Wrapper for [`Package`] with marking wherever given package is direct
/// transitive dependency from the crate being built
pub struct PackageDetails<'package> {
    /// If set to true, it means this crate is a direct transitive dependency
    /// of the crate being built
    pub is_dependency: bool,
    /// Set to true for local packages
    pub is_local: bool,
    /// Package being a dependency
    pub package: &'package Package,
}

impl<'package> PartialEq for PackageDetails<'package> {
    fn eq(&self, other: &Self) -> bool {
        self.package == other.package
    }
}
impl<'package> Eq for PackageDetails<'package> {}

impl<'package> Hash for PackageDetails<'package> {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.package.hash(state);
    }
}

impl<'package> PackageDetails<'package> {
    /// Creates new instance of [PackageDetails]
    /// 
    /// Created instance is marked as not a dependency of the crate being built
    pub fn new(package: &'package Package) -> Self {
        Self{ 
            is_local: false,
            is_dependency: false,
            package 
        }
    }

    /// Mark the package as a dependency (of root node).
    pub fn set_is_dependency(&mut self) {
        self.is_dependency = true;
    }

    /// True if the package is a dependency (of the root node, inclusively)
    pub fn is_dependency(&self) -> bool {
        self.is_dependency
    }

    /// Mark the package as local dependency
    pub fn set_is_local(&mut self) {
        self.is_local = true;
    }

    /// Returns `true` if package is a local dependency
    pub fn is_local(&self) -> bool {
        self.is_local
    }
}

/// Generates the `main.css` file and executes the `tailwindcss` command
pub struct Tailwind<'this>{
    /// Control over output 
    console: &'this Console<'this>,
    /// Cargo metadata
    metadata: Metadata,
    /// Output directory
    /// 
    /// Directory where the temporary files should be placed.
    /// 
    /// - If set to [`Some`], then it will be used directly
    /// - If set to [`None`], then tailwind integration will
    ///   
    ///   1. Inspect the `OUT_DIR` env variable
    ///   2. To the path from `1` append `leptos_forge/build_script/tailwind` to make
    ///      it separate from the rest of the output
    ///
    out_dir: Option<String>,
    /// Should we auto watch the local dependencies for changes
    /// 
    /// If set to true the tailwind integration will print a bunch of 
    auto_local_watch: bool,
}

impl<'this> Tailwind<'this> {
    /// Create a new instance of the [Tailwind] runner
    /// 
    /// # Arguments 
    /// 
    /// - **metadata** - Cargo metadata
    /// - **console** - formatter for the information printed out to the terminal
    ///   during tailwind integration run
    /// - **out_dir** - see [Tailwind::out_dir]
    /// - **auto_local_watch** - wherever watching for changes in the local crates
    ///   should be enabled.
    ///   For details see [TailwindConfiguration::watch] 
    pub fn new(
        metadata: Metadata,
        console: &'this Console<'this>, 
        out_dir: Option<String>,
        auto_local_watch: bool,
    ) -> Self {
        Self { console, metadata, out_dir, auto_local_watch}
    }

    /// Runs the tailwind integration
    /// 
    /// 
    /// # Arguments
    /// 
    /// - **out_dir** - output directory for the 
    /// 
    /// # Errors
    /// 
    /// - if you run the tailwind integration at the workspace level
    /// 
    /// # Undefined behavior
    /// 
    /// - if you run the method outside of the cargo build script
    /// 
    /// # Panics
    pub fn run(&self) -> Result<Utf8PathBuf, String> {

        let Some(root_package) = self.metadata.root_package() else {
            let error = formatdoc!(r#"
                Tailwind integration is intended to be run from the build script.
                It looks like you've somehow run the Tailwind integration from the workspace
                directory when you should have run it at the crate level.
                
                Workspace root: {}
                "#,
                self.metadata.workspace_root
            );
            self.console.error(&error);
            
            return Err(error)
        };

        let out_dir: Utf8PathBuf = match self.get_out_dir(root_package) {
            Ok(out) => out,
            Err(e) => {
                self.console.error(&e);
                return Err(e);
            }
        };

        let packages: HashMap<PackageId, PackageDetails<'_>> = {
       
            let console = self.console.stage("packages");
            match self.get_packages() {
                Ok(p) => p,
                Err(message) => {
                    console.error(&message);
                    return Err(message)
                }
            }
        };

        // Filter out packages that aren't in the dependency tree.
        let dependencies: Vec<&PackageDetails> = 
            packages.iter()
                .filter(|(_id, details)| details.is_dependency())
                .map(|(_id, details)| details)
                .collect::<Vec<_>>();

        // self.console.error(&formatdoc!(r#"
        //     Dependencies: {dependencies:#?}
        //     "#
        // ));

        // Find the declared resources in the dependency tree
        let mut declared_resources: HashMap<&PackageDetails, TailwindConfiguration> = HashMap::new();
        {
            let console = self.console.stage("imports");

            for package in dependencies {
                if let Err(error) = self.get_package_resource_data(package, &mut declared_resources) {
                    console.error(&error);
                    return Err(error);
                }
            }

        }

        let mut import_statements = Vec::new();
        for (package, configuration) in declared_resources.iter() {
            let import = self.build_import_statement(package, configuration)?;
            import_statements.push(import);
        }
        let import_statements = import_statements.join("\n");

        if self.auto_local_watch {
            self.watch_dependencies(&declared_resources);
        }

        let file_content = format!(
            "{GENERATED_CSS_FILE_PREFIX}\n{import_statements}"
        );

        if let Err(e) = create_dir_all(&out_dir) {
            return Err(formatdoc!(r#"
                While creating the directory for tailwindcss entry file {out_dir}, an error occurred: {e}"#,
            ));
        }

        let mut source = out_dir.clone();
        source.push("main.css");
        
        {
            let file  = match File::create(&source) {
                Err(e ) => {
                    return Err(formatdoc!(r#"
                        Unable to crate source tailwind file

                            Source file path: {source}
                            File creation error: {e}
                        "#
                    ));
                },
                Ok(file) => file
            };
            if let Err(e) =  writeln!(&file, "{file_content}") {
                return Err(formatdoc!(r#"
                    Unable to write content into the tailwind source file
                    
                        Source file path: {source}
                        Write error: {e}
                    "#
                ));
            }
        }

        self.console.info(&format!("Wrote source file: {source}"));

        let root_path = root_package.manifest_path.parent().unwrap();
        let root_details = PackageDetails::new(root_package);
        
        // This works because the package details definition is broken in eq and hash
        let config = declared_resources.get(&root_details).unwrap();
        let output_path = root_path.join(config.output.clone().unwrap_or_else(|| "target/resources/main.css".into()));
        let output_path = match soft_canonicalize(&output_path) {
            Ok(p) => p,
            Err(e) => {
                return Err(formatdoc!(r#"
                    "Error while canonicalizing the output_path

                        Output path: {output_path}
                        Error: {e}
                    "#
                ));
            }
        };

        let output_path = Utf8PathBuf::try_from(output_path).unwrap();
        self.console.info(&format!("Canonical tailwindcss output path is: {output_path}"));

        let mut tailwind: Command = Command::new("tailwindcss");
        tailwind
            // .env("DEBUG", "*")
            .args(vec![
                "--input",
                source.as_str(),
                "--output",
                output_path.as_str(),
                "--optimize",
                "--verbose",
            ]);

            
        self.console.info(&format!("\ntailwindcss command:\n\n\t\t{:?}", tailwind));
        let output = tailwind.output().expect("Do you have a tailwind in your execution path?");

        if !output.status.success() {
            self.console.error(&format!("Tailwind Stopped with an {}", output.status));
            self.console.error(&"\n--------[ STDOUT ]------------------------\n\n");
            self.console.println(&String::from_utf8_lossy(&output.stdout));
            self.console.error(&"\n--------[ STDERR ]------------------------\n\n");
            self.console.error(&String::from_utf8_lossy(&output.stderr));
        } else {
            self.console.info(&"Tailwind run successfully");
            self.console.info(&"");
            self.console.info(&"--------[ STDOUT ]------------------------");
            self.console.info(&"");
            self.console.info(&String::from_utf8_lossy(&output.stdout));
            self.console.info(&"");
            self.console.info(&"--------[ STDERR ]------------------------");
            self.console.info(&"");
            self.console.info(&String::from_utf8_lossy(&output.stderr));
        }

        Ok(output_path)
    }

    /// Builds the list of packages
    /// 
    /// Packages returned are marked wherever they are direct dependency of the
    /// built crate or not.
    /// 
    /// # Errors
    /// 
    /// Function will error if
    /// 
    /// - it's run for whole workspace
    /// 
    ///   Tailwind integration is intended to be run at the crate level
    ///   
    /// - If `metadata` doesn't contain the dependency graph
    /// - If `metadata.root_package` is not on the dependency graph node list
    /// - If `metadata.packages` does not reflect dependency graph information
    pub fn get_packages(&self) -> Result<HashMap<PackageId, PackageDetails<'_>>, String> {
        let mut packages_by_id: HashMap<PackageId, PackageDetails> = HashMap::new();
        // Initialize the lookups without the dependency information (i.e. not in root deps)
        for package in self.metadata.packages.iter() {
            packages_by_id.insert(
                package.id.clone(),
                PackageDetails::new(package)
            );
        }
        // Use the dependency tree from root to fix the dependency information
        let root_package: &Package = self.metadata.root_package()
            .ok_or(formatdoc!(r#"
                Tailwind integration is intended to be run from the build script.
                It looks like you've somehow run the Tailwind integration from the workspace
                directory when you should have run it at the crate level.

                Workspace root: {}
                "#,
                self.metadata.workspace_root
            ))?;
        // Convert the dependency nodes from a list to a map!
        let dep_graph_root: &Resolve = self.metadata.resolve.as_ref().ok_or("cargo_metadata::Metadata doesn't have a dependency graph")?;
        let node_list = &dep_graph_root.nodes;
        let node_map: HashMap<PackageId, &Node> = node_list.iter().map(|n| (n.id.clone(), n)).collect();
        // All packages from the root node are dependencies so we could recursively visit all the dependencies
        // and then add them. However, using a stack and a set allows us to cut repetition.
        let mut processed_packages: HashSet<&PackageId> = HashSet::new();
        let mut pending_nodes: Vec<&&Node> = vec!(node_map.get(&root_package.id).ok_or("Missing dependency node")?);
        while let Some(node) = pending_nodes.pop() {
            // Set as a dependency
            let details: &mut PackageDetails<'_> = packages_by_id.get_mut(&node.id).ok_or("Missing details.")?;
            details.set_is_dependency();

            if details.package.source.is_none() {
                details.set_is_local();
            }

            // Add to done
            processed_packages.insert(&node.id);

            // Add any unprocessed nodes to the pending queue.
            for pkg in &node.dependencies {
                if !processed_packages.contains(pkg) {
                    pending_nodes.push(node_map.get(pkg).ok_or("Missing details.")?);
                }
            }
        }
        Ok(packages_by_id)
    }


    /// Get all the resources information declared by a package 
    /// 
    /// Method checks if paths are relative in form
    /// 
    /// # Errors
    /// 
    /// Method returns an error
    /// 
    /// - if configuration is in the wrong format
    /// - if provided paths are not relative
    /// 
    pub fn get_package_resource_data<'package>(
        &self,
        details: &'package PackageDetails<'package>,
        resources: &mut HashMap<&'package PackageDetails<'package>, TailwindConfiguration>,
    ) -> Result<(), String> {
        // We have the metadata, resources uses cargo_resources.provides as a collection within this!
        let cargo_resource_metadata: &Value = &details.package.metadata["leptos_forge"];

        if !cargo_resource_metadata.is_object() {
            // self.console.warn(&format!("No metadata for package {}", package.name));

            return Ok(()); // No metadata for us
        }
        let tailwind_metadata: &Value = &cargo_resource_metadata["tailwind"];
        let config: Result<TailwindConfiguration, serde_json::Error> = serde_json::from_value(tailwind_metadata.clone());
        let Ok(config) = config else {
            return Err(formatdoc!(r#"
                Invalid leptos_forge metadata for tailwind integration in crate {}

                Expected:

                    [package.metadata.leptos_forge.tailwind]
                    lib="relative/path/to/lib.css"
                    output="relative/path/to/target/result.css"
                    watch=[]

                    - lib - optional, relative path to the tailwind configuration for this crate. This file will be imported from the generated tailwindcss file
                    - output - optional, relative path to the output of the tailwindcss
                    - watch - optional, list of paths which will be passed to `cargo::rerun-if-changed=PATH` relative to the crate Cargo.toml
                "#,
                details.package.name)
            );
        };

        if let Some(lib) = &config.lib &&
            !lib.is_relative() {
            return Err(formatdoc!(r#"
                Path provided as value of lib in leptos_forge metadata is invalid in crate {}

                Path provided as lib value must be relative to the crate's Cargo.toml
                "#,
                details.package.name
            ));
        }

        if let Some(output) = &config.output &&
            !output.is_relative() {
            
            return Err(formatdoc!(r#"
                Path provided as value of output in leptos_forge metadata in invalid in crate {}

                Path provided as output must be relative to the crate's Cargo.toml
                "#,
                details.package.name
            ));
        }

        resources.insert(details, config);

        Ok(())
    }


    /// Builds the output directory path
    /// 
    /// # Errors
    /// 
    /// - if [`Console::out_dir`] is not set and OUT_DIR environment variable is
    ///   not set
    pub fn get_out_dir(&self, root: &Package) -> Result<Utf8PathBuf, String> {
        if let Some(out_dir) = &self.out_dir {
            Ok(Utf8PathBuf::from(out_dir))
        } 
        else {
            let Ok(env) = env::var("OUT_DIR") else {
                return Err(formatdoc!(r#"
                    While building {} tailwind integration was not able to find the OUT_DIR environment variable.

                    Are you running tailwind integration from build script?
                    "#,
                    root.name
                ));
            };

            let path = env + "/" + CARGO_OUTDIR_SUFFIX;

            Ok(Utf8PathBuf::from(path))
        }
    }

    /// Build import statements to be included in the tailwind css source file
    /// 
    /// # Errors
    /// 
    /// Returns an error 
    /// 
    /// - if we can't locate the manifest directory for `package`
    /// - 
    pub fn build_import_statement(&self, details: &PackageDetails, configuration: &TailwindConfiguration) -> Result<String, String>{
        let Some(package_root) = details.package.manifest_path.parent() else {
            return Err(formatdoc!(r#"
                Unable to locate the manifest directory for crate {}
                
                This is could be either

                - nonstandard compilation environment
                - bug in `leptos_forge_build_script` tailwind integration
                "#,
                details.package.name
            ));
        };

        if let Some(lib) = &configuration.lib {
            let lib_path = package_root.join(lib);

            Tailwind::is_valid_resource_path(details.package, package_root, &lib_path)?;

            return Ok(formatdoc! {r#"
                /* Crate {} */
                @import "{lib_path}";
                
                "#,
                details.package.name
            })
        }
        
        Ok(String::new())
        
    }

    /// Checks if `resource` is under the `root` path
    /// 
    /// # Errors
    /// 
    /// - If can't canonicalize `root` path
    /// - If can't canonicalize `resource` path
    /// - If `resource` is not inside `root` path`
    /// - If `resource` doesn't exits
    /// - If `resource` contains `'` or `"`
    pub fn is_valid_resource_path(package: &Package, root: &Utf8Path, resource: &Utf8PathBuf) -> Result<(), String> {
        let Ok(root) = root.canonicalize_utf8() else {
            return Err(formatdoc!(r#"
                Unable to canonicalize root directory for {} crate

                    Root path: {}
                "#,
                package.name,
                root
            ));
        };

        let resource = match resource.canonicalize_utf8() {
            Err(e) => {
                return Err(formatdoc!(r#"
                    Unable to canonicalize resource path for {} crate

                        Resource path: {}
                        Error: {e}
                    "#,
                    package.name,
                    resource
                ));
            },
            Ok(r) => {
                r
            }
        };

        let resource_path = resource.to_string();

        if resource_path.contains("\"") ||
            resource_path.contains("'") {
            
            return Err(formatdoc!(r#"
                Canonical forms of the leptos_forge.tailwind.lib metadata in {} crate contain the quotation mark or apostrophe

                    Resource path: {}
                "#,
                package.name,
                resource_path
            ))

        }

        if !resource.starts_with(&root) {
            return Err(formatdoc!(r#"
                Resource is not in the root directory for {} crate

                    Canonical root path: {root}
                    Canonical resource path: {resource}
                "#,
                package.name
            ))
        }

        if !resource.exists() {
            return Err(formatdoc!(r#"
                Resource path defined in leptos_forge.tailwind.lib metadata in {} crate doesn't exists

                    Resource path: {}
                "#,
                package.name,
                resource
            ))
        }

        Ok(())
    }

    /// Runs logic which will force the cargo to rerun the build script if your
    /// local dependencies are changed
    pub fn watch_dependencies(&self, local_dependencies: &HashMap<&PackageDetails, TailwindConfiguration>) {
        let console = self.console.stage("watch");
        for (details, config) in local_dependencies {
            if details.is_local {
                let Some(package_root) = details.package.manifest_path.parent() else {
                    console.warn(&formatdoc!(r#"
                        Unable to find the parent directory of the manifest_path for {} create
                        "#,
                        details.package.name
                    ));

                    continue;
                };

                if config.watch.is_empty() &&
                    let Some(lib) = &config.lib {
                    if let Some(lib_parent) = lib.parent() {
                        let lib_parent = match package_root.join(lib_parent).canonicalize_utf8() {
                            Err(e) => {
                                console.warn(&formatdoc!(r#"
                                    Unable to canonicalize resource path for {} crate

                                        Resource path: {}
                                        Error: {e}
                                    "#,
                                    details.package.name,
                                    lib_parent
                                ));
                                continue;
                            }
                            Ok(p) => p
                        };

                        console.info(&format!("Observing: {} - {lib_parent}", details.package.name));
                        std::println!("cargo::rerun-if-changed={lib_parent}");
                    }
                    else {
                        console.warn(&formatdoc!(r#"
                            Unable to find the parent directory of the lib file set in configuration for {} crate

                                Lib path: {}
                            "#,
                            details.package.name,
                            lib,
                        ));
                    }

                    for target in &details.package.targets {
                        if target.is_cdylib() ||
                           target.is_dylib() ||
                           target.is_lib() ||
                           target.is_rlib() ||
                           target.is_staticlib() {

                            let Some(src) = target.src_path.parent() else {
                                continue;
                            };

                            console.info(&format!("Observing: {} - {src}", details.package.name));
                            std::println!("cargo::rerun-if-changed={src}");

                        }
                        
                    }

                }
                else {
                    for to_watch in &config.watch {
                        let path = package_root.join(to_watch);

                        let path = match path.canonicalize_utf8() {
                            Err(e) => {
                                console.warn(&formatdoc!(r#"
                                    Unable to canonicalize resource path for {} crate

                                        Resource path: {}
                                        Error: {e}
                                    "#,
                                    details.package.name,
                                    path
                                ));
                                continue;
                            }
                            Ok(p) => p
                        };

                        console.info(&format!("Observing: {} - {path}", details.package.name));
                        std::println!("cargo::rerun-if-changed={path}");
                    }
                }
            }
        }
    }
}
